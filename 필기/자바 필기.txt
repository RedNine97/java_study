생활코딩 주소
https://opentutorials.org/course/1223/6339

public(웹에서 불러오기) static(정적) void(빈 값, 아무거나 받겠다) main
객체형=참조형=클래스명       객체에 저장된 값은 메모리상의 주소값이다.
객체 = 인스턴스 = 참조변수 = 레퍼런스변수 = 포인터변수

byte -> short -> int -> long -> float -> double   묵시적형변환
           char

객체 : 눈에 보이는 모든 사물을 지칭한다.
객체 생성 : 데이터를 저장할 공간을 만는 것이다.
      **형식) 클래스명 객체명 = new 클래스명();
객체를 멤버변수에 저장하는 형식은?
         형식) 객체명.멤버변수명 = 값

클래스의 구성요소 : 새로운 자료형을 만들어낸다.
1. 멤버변수 : 데이터 저장이 목적이다.
형식)객체명.멤버변수 = 저장할 값

**2. 메서드 : 멤버변수를 통해 저장된 데이터를 조회, 수정, 삭제한다.
       어떤 기능을 가진 최소한의 작업단위이다.
**(1) 일반 메서드 : 객체가 생성돼야 호출이 가능하다.
  (2) 정적 메서드 : 객체생성없이 호출이 가능하다.

  ** 메서드의 종류 **
   1. 매개변수 X  반환값 X =>단순하고, 반복적인 일을 할때 사용한다.
   2. 매개변수 O  반환값 X =>데이터를 입력하여 저장, 계산, 출력할 때 사용한다.
** 3. 매개변수 O  반환값 O =>계산, 웹프로그래밍할 때 사용한다.

변수 - 하나의 데이터를 저장할 수 있는 공간
배열 - 같은 타입의 여러 데이터를 저장할 수 있는 공간
클래스 - 데이터와 메서드의 결합

절차지향 프로그래밍이란?
일을 처리하는 순서, 과정을 프로그래밍으로 구현하는것이다. (재사용 불가)

객체지향 프로그래밍이란?
프로세스 중심이 아닌 객체중심으로 프로그래밍으로 구현하는것이다. (재사용 가능)

지정자(modifier)
접근 지정자(access modifier) : public, (defulte), protected, private
일반 지정자(modifier) : static, abstract, final 등,,,

getter 메서드 : 멤버변수의 값을 얻어올때 사용한다.
         public String getName() { return name; }
setter 메서드 : 멤버변수에 값을 할당할 때 사용한다.
         public void setName(String n) {
           name=n;
         }

생성자 : 객체를 생성할때 맨 처음 자동으로 호출되는 특수한 메서드이다.
   용도 - 객체변수를 초기화 한다.

overloading 생성자 : 같은 클래스에서 동일한 이름의 생성자가 여러개 존재한다.
overloading 메서드 : 같은 클래스에서 동일한 메서드가 여러개 존재한다.

패키지(package) : 같은 종류의 클래스들을 모아놓은 그룹이다.
- 클래스들의 관리 목적으로 사용된다.

import : 패키지가 다른 클래스 접근시 사용한다.
형식) import 패키지명.클래스명; or import 패키지명.*;
- 모든 API 사용할 때는 반드시 import해야 한다.
----------------------------------------------------------------
클래스란?
객체의 속성과 기능을 코드를 구현한 것이다.

멤버변수란?
클래스 내부에 선언하여 객체 속성을 나타내는 변수이다.

메서드란?
어떤 기능을 가진 최소한의 작업단위이다.

**메서드를 사용하는 이유는?
1. 중복된 코드의 제거
2. 높은 재사용성으로 계속 호출해서 사용이 가능하다.
3. 프로그램의 구조화때문이다.

함수의 장점(=메서드의 장점)은?
1. 기능을 나누어 코드를 효율적으로 구현할 수 있다.
2. 같은 기능을 매번 코드로 만들지 않아도 돼어 편리하다.
3. 디버깅 작업을 할 때에도 편리하다.

생성자는?
객체를 생성할때 맨 처음 자동으로 호출되는 특수한 메서드이다.
- 디폴트 생성자 -
: 클래스를 생성할때만 호출한다.
  생성자명은 클래스명과 동일해야 한다.
  생성자는 반환값이 없다.(void를 의미하지 않음)

추상화는? (클래스와 객체)
클래스를 만들어내는 일련의 과정이다.
새로운 대상자를 저장할 목적으로 만들어진 설계도이다.

추상화의 문제점은?
엉터리 값이 저장되어 저장할 가치가 없다. 이에 캡슐화를 사용한다.

클래스를 만드는 이유는? (추상화)
데이터를 저장할 목적으로 사용된다.
움직이는 대상자는 저장할 수 없다.

클래스의 종류
1. main()을 가진 클래스 => 실행목적(화면에 결과를 보여줄 목적)으로 사용한다.
2. main()가 없는 클래스 => 저장목적으로 사용한다.

자바의 기본자료형은 (  ) 개가 있다. => 8
정수형 : byte(1바이트), short(2바이트), int(4바이트), long(8바이트)
실수형 : float(4바이트), double(8바이트)
문자형 : char(2바이트)
논리형 : boolean

===============================================
============== < 2일차 > ==========================
==============================================
** 식별자 ** =>식별자의 개요및 특성을 아는대로 2개이상 기술하시오.

식별자의 개요
: 변수, 패키지, 메서드(동사), 클래스(명사) 이름을 만들어 주는 규칙이다.

** 식별자의 규칙 ** = 특성
1.첫 글자는 숫자가 오면 안된다.->package j0607
2.영문자+숫자+특수기호를 조합해서 작성해야한다.  주의) 특수기호->_,$은 사용 가능하다.
3.대소문자 구별을 한다.
4.예약어는 식별자로 사용할 수가 없다.

**8가지 자료형=기본자료형 ** <-->참조형 자료형(=클래스형(5장),배열(7장),인터페이스(10장)

1.수치형(=숫자)=>정수=>byte->short->int->long
                    소======================>대

*1)byte=>(-127~128)만 저장==>저장공간 크기(1 byte)
        =>자바에서 기본 데이터 전송단위(채팅->문자열) =>**자바의 입출력(ex 파일첨부)
          *****************************

  2)short ->2byte기억공간 크기(-32768~32767)

*3)int => 4byte 기억공간 크기만큼 저장이 가능
          (-2147483648~2147483647)=>-21억 ~ 21억
        =>자바에서의 기본 연산단위로 사용(+,-,*,/ =>산술연산자)
        =>형변환과 연관
          *******************************
*4)long =>8byte 기억공간 크기만큼 저장이 가능
         만약에 long형으로 저장하라=>저장하는 값뒤에 L or l를 써주어야한다.

실수

*float=>4byte 기억공간크기를 가지고 있다.
          float f=5.3;(X)  ->double f=5.3
          소수점 뒤에 F or f를 줘면 float으로 저장한다는 표시

*double=>8byte 기억공간크기를 가지고 있다.
자바에서는 소수점이 있는 실수값을 저장할때 무조건 double형으로
인식한다.

2.논리형=>참,거짓을 판별할 수 있는 값
  boolean=>true or false

3.문자형=>문자 하나 저장->char->char str='a';
                (2byte)=>0~65535까지 저장(양수)
  =>short(2byte)

<----소            (크기)             ---------------->대
byte->short->int->long->float->double  =>String(X) 기본자료형에 포함(X)
           char

**아스키코드값=>특수기호,숫자,영문자,한글,,,입력=>내부적으로
                       각 문자를 숫자형태로 저장(=코드값)

아스키코드값=>0~255 까지 저장
==>한글,일본어,중국어(언어체계),,,비영어권(UTF)=>유니코드

영어권 제외 다른 나라에서는 아스키코드 말고 유니코드를 사용

**유니코드=>아스키코드값의 확장판
              (비영어권 사람들에게 자기 나라 언어로 개발할수 있도록
               설계된 코드값) 0~65535

** String=>문자열->'a'+'b'=>"ab" ->'ab', "ab"(자바스크립트)
                            '한'+'글'=>"한글"

**자바에서는 문자열은 기본자료형이 아니고 참조형이다. ***
   참조형=클래스형

< 연산자 >

1.산술연산자=>단항산술연산자=>+,-,++,--  =>부호(양,음수)
                                      +3,-3 ====
                    이항산술연산자=>a(항)+b(항)=>+,-,*,/,%(나머지)
                                                                =====
                        a(피연산자)+b(피연산자)=c
                           연산이 되는 대상자

**2.증감연산자=>++,--

      특정변수의 값을 하나 증가 시키거나 또는 감소시키는 역할
      시키는 연산자->증감연산자=>++,--

형식)  ++(--) 변수=>전위연산자->먼저 계산이 되는경우
        변수++(--)=>후위연산자=>나중에 계산이 되는 경우

3.관계연산자 --> 관계 ( =,>,<,<=, !=(같지않다.), == )
4.논리연산자 --> 참과 거짓을 판별 ( &,|,^, &&, ||, !(NOT) )

명제(진리표)

!= <> ,^= (오라클)

&&,& (and),  ||, | (or), ^(XOR)=>배타적인 결합
   그리고            또는            T    T  =>두항이 같으면 F
                                          F     F
T     T ->T    T  T->T           두 항이 다르면 참
                    T  F->T           (T  F) or (F   T)=>T
                    F  T->T
                    F  F->F

**********************
(2>3)  && (5<7) =>조건평가
==T====T===>T
                F
                F===>F
    F--------------->F

첫항의 결과에 따라서 두번째항을 계산할수도 안할수도 있는 방식

**********************
(2>3)  & (5<7) =>모두 평가

  =>첫항의 결과와 상관없이 무조건 두번째항을 계산하는 방식
**************************************
요즘->구분하지 않고 사용한다.

===============================================
============== < 3일차 > ==========================
==============================================
** 형변환 개요 : 연산중간에 자료형이 변환이 되는 경우가 있다.

** 형변환의 종류 **(비교,설명하시오.(서술형) ncs)
1. 묵시적인 형변환(=자동형변환)
: 적은 데이터 값에서 큰 데이터 공간에 저장한다.

2. 명시적인 형변환
: 작은 데이터가 큰 데이터로 변환된다.
단점 - 데이터 손실이 일어날 수 있다.

byte->short->int->long->float->double  =>기본형끼리의 형변환
          char

제어문(control)  : 조건에 따라서 실행될수도 되지않을수도 있는 구문이다. (참,거짓)

순차문  : 문법에 맞게 코딩한 순서대로 실행이 되는 구문

** 제어문의 종류 **
  1. 조건문(=분기문) : 조건에 따라서 참,거짓인 조건을 갈라져서 실행이 된다.
                      선택문(switch-case), 중첩 if문
**2. 반복문 : 조건에 따라서 반복하는 문장이다.
      for, while, do~while

순서도(Flow Chart) : 문제 해결단계를 일정한 기호를 이용하여 나타내는 다이어그램이다.

===============================================
============== < 4일차 > ==========================
==============================================

**while와 do~while 구문의 차이점**
: while(조건식)은 처음부터 거짓이라면 한번도 수행할 수 없지만,
  do~while(조건식)은 처음부터 거짓이라도 한번은 수행한다.

for문 형식
반복할 횟수를 기억할 변수
for (초기식; 조건식; 증감식;) {}

** 이중 for문 = 중첩 for문

탈출문 (break, continue, return)
: 제어문의 반복문 중에서 어느 특정 조건에 따라서 더 이상 문장을 수행하지 않고
   중간에 빠져나가는 문장이다.
1. breake문 : 특정 조건에 만족하는 경우 루프를 탈출한다.
2. continue문 : continue 이하 구문을 수행하지 않고 스킵(skip)한다.
- while,do~while 경우 ==>조건식으로 이동
- for문 경우  ========>증감식으로 이동

===============================================
============== < 6일차 > ==========================
==============================================

** 캡슐화의 개요 ***
데이터를 보호, 은닉하는 목적으로 사용한다.
(오라클의 제약조건과 의미가 비슷하다.)

< 캡슐화 > (형식 및 공식)

(1) 멤버변수 입력
private 자료형 멤버변수;

(2) setter Method(저장) <- 입력 받아서 저장하기 때문에 반환값이 없다.
public void setXXXX(매개변수_자료형 변수명){멤버변수=매개변수}   

(3) getter Method(불러와서 출력) 작성
public 자료형_반환형 getXXXXX()

다형성 => 같은 메서드를 호출해서 실행되는 결과는 다 다르다.
   ex) 문화적인 차이
------------------------------------------------------------
  생성자(Constructor) -> 오버로딩(Overloadding) -> this?
-----------------------------------------------------------

**생성자 개요(=개념)**
객체를 생성할때 맨 처음 자동으로 호출되는 특수한 메서드이다.

형식)
수동으로 호출하는 방법 : 객체명.일반메서드명(~)
기본생성자 : 접근지정자(public) 생성자(=클래스명)(){}

생성자 목적 : 데이터를 저장할 수있는 공간을 만들기 위해서이다.
------------------------------------------------------------------------
** 자바에서 데이터를 저장시키는 방법 **
1.일반적인 방법은 엉터리값이 저장될 가능성이 있다. (객체명.멤버변수=값)
2.캡슐화를 통한 Setter Method를 통해서 값을 저장한다. (올바른 값만 선별)
3.생성자를 통해서 값을 저장시킬 수 있다.

-------------------------------------------------------------------------
** Setter Method와 생성자의 공통점 및 차이점(서술형)***

공통점 : 멤버변수에 데이터를 저장한다.

차이점 : 생성자는 객체생성 시에만 호출이 되어 임의로 계속 호출할 수 없고,
Setter Method는 중간에 데이터를 수정할 필요가 있어 임의로 계속 호출이 가능하다.
--------------------------------------------------------------------------

오버로딩(Overloadding)
메서드명을 하나로 통합할 때 매개변수 갯수와 자료형을 가지고 서로 다른 메서드 처럼 사용할 수 있게
만드는 기법

1. 생성자 오버로딩
    생성자 오버로딩 목적 : 다양한 방법으로 멤버변수의 값을 초기화(=저장)시킬 수가 있다.
    생성자 메서드의 호출 방법 : 객체명.일반메서드명(~)
   (1)생성자 내부에서는 자기 클래스의 객체명을 사용할 수 없다. ( X )
   (2)생성자 내부에서는 다른 클래스의 객체명은 사용할 수 있다. ( O )
2. 메서드 오버로딩
     메서드 오버로딩을 구현하기위한 조건 ***
      1) 메서드의 이름은 같아야 한다.
      2) 메서드의 매개변수를 다르게 설정하더라도 서로 자료형이 달라야된다.
      3) 메서드의 자료형을 다르게 설정해야 한다.

추상화 : 멤버변수,생성자,일반메서드내용=->모든 클래스

설계도 : 데이터를 저장하고, 반드시 주소가 필요하다.

***************************************
설계도를 작성할때 외부에서 어떤 객체명으로 작성해서 접근할지 뭐가 없다.
=>어떠한 이름이라도 다 받아서 대신 처리해주는 객체이름이 필요하다.
=>this

****************************************

*** 용어 정리 ****
This : 현재 생성된 객체를 가리키는 예약어(=키워드)로 사용한다.

This 개념
1) 현재 생성된 객체를 가리키는 예약어
2) 메서드의 매개변수와 멤버변수가 같으면 구분해주기위해서 멤버변수앞에 써준다.

This 특징
임의로 호출 :
- 생성자는 임의로 호출할 수 없다.
- 객체를 생성하면 자동적으로 생성자가 호출된다.
생성자 :
- 다른 생성자를 호출할때 처음 시작점이 되는 생성자는 임의로 호출할 수 가 없다.
- 첫 번째 이후 생성자부터는 임의로 다른 생성자 호출이 가능하다.

***********************************************
  첫 번째 생성자는 임의로 호출할 수 없다. (객체를 생성할때만 호출이 가능)
  두 번째 생성자부터는 임의로 호출이 가능하다.

***********************************************
  this() => 기본 생성자를 호출하라는 표시
  this(1) => 인수 1개짜리 정수형값을 받아서 처리해주는 생성자 호출하라
  this(1,"홍길동") => 인수 2개짜리 처리해주는 생성자 호출하라
      첫 번째 인수는 정수, 두 번째인수 문자열처리
   ,,,,
  ----------------------------------------------------------

문제 예시) *** 메서드의 종류(매개변수,반환형을 기준) 비교,설명하시오.
               --------
   1.매개변수 X 반환형 X -- (단순,반복적인 문장처리)
    2.매개변수 O 반환형 X -- (입력 받아 저장,계산,출력)
             *3.매개변수 O 반환형 O -- (계산목적, 웹프로그래밍에서 많이 사용)

            *** 메서드의 종류를 메모리 관점에서 작성 ***
   1. 일반 메서드(객체생성하여 호출) - 멤버 변수
   2. 정적 메서드(객체를 생성하지 않고 메서드 호출) - static

1. 일반 메서드
형식) 객체명.메서드명(~)

2. 정적 메서드
형식1) static 메서드명

형식2) [접근지정자] static 반환형

**정적메서드 호출하는 방법**
static main() 정적 ---> 일반메서드 호출
형식) 객체명.일반메서드명(~)

static 정적메서드--->정적메서드
형식) 클래스명.정적메서드(~)  or 정적메서드(~)
   => 클래스명을 생략할 수 있고, ***같은 자기 클래스내부에서만 가능
   => 다른 클래스의 정적메서드를 불러올때에는 클래스명을 생략할 수 없다.                            


**배열(array)
: 같은 타입의 여러 변수를 하나의 묶음으로 다루는 것

**단점
  1) 변수의 이름이 많아지면 관리상의 어려움
  2) 처리속도가 느려질 수 있다.->저장위치가 랜덤으로 저장
--------------------------------------------------------------------
p138~139 참조
***** 자바의 메모리 구조 **=>기술면접(면접할때 IT지식을 물어보는 경우가 있다.)

static main > static 멤버변수 > 지역변수, 매개변수(호출하고 사라짐) >
          (스텍 영역 - static)            (힙영역 heap - 객체)    

  인스턴스=객체=참조변수=레퍼런스변수 ==>객체

------------------------------------------------------------------------------------------
** 상속 **(물려준다)
형식) class 자식클래스명 extends 부모클래스명

1. 슈퍼클래스(super)(=부모, 상위)

2. 서브클래스(sub)(=자식, 하위)

상속의 장점
1) 기존의 부모클래스의 멤버변수, 메서드를 그대로 사용할 수 있다.
2) 코딩양이 줄어들고 개발시간이 단축된다.

상속의 특징
1) 생성자는 상속이 불가능하고, private로 선언된 멤버변수와 메서드는 상속이 불가능하다.
2) 다중상속이 불가능하지만, 순차적으로 단일상속은 가능하다.(동시 X, 순차적 O)
3) 기능이 많아지고 중복을줄여주는 누적제 방식이다.

상속의 단점
부모로 부터 물려받은 메서드를 자식입장에서 그대로 사용하면 문제가 발생할 수 있다.

**오버라이딩**
부모의 물려받은 메서드를 자식클래스 내부에 맞게 재정의하는 기법이다.

*** 상속관계 ****
상속을 받게되면 생성자는 상속이 안된다.(private 접근지정자와는 상관X)

this->자식클래스의 객체를 가리키는 예약어
this()->자식클래스의 생성자를 호출하라는 문장

super->부모클래스의 객체를 가리키는 예약어
super()=>부모클래스의 생성자를 호출하라는 문장   => 생략이 가능

super(1)=>부모클래스의 인수1개짜리 생성자호출
super(1,"홍길동")=>부모클래스의 인수2개짜리 생성자호출 하라는문장

결론 => 상속관계에서 부모, 자식클래스의 멤버변수와 메서드가 같으면
             어떻게 구분해서 호출할것인데?

멤버변수 ==> super.멤버변수 => 부모의 것으로 인식
                    this.멤버변수 => 자식의 것으로 인식 => this은 생략가능

메서드 ==> super.부모메서드명() =======> 부모의 메서드명
                 this.메서드명() -> 자식의 메서드 호출
--------------------------------------------------------------------
접근지정자(=접근권한자) : 외부에서 필요로하는 클래스를 불러올때 사용하는 지정자를 의미한다.
       - 멤버변수, 메서드에 부여한다.

접근지정자 (10일차 접근지정자.PPT 그림 참조)
1. private 접근지정자
1) 자기 클래스 내부에서만 접근가능하다.
2) 같은 패키지(=폴더)에서는 접근 X
3) 다른 패키지에서도 접근 X

2. (default) 접근지정자
    1) 같은 패키지에 있는 클래스들끼리 접근이 가능하다. (O)
    2) private 포함 자기 클래스내에서도 접근이 가능하다. (O)
    3) 다른 패키지에 있는 클래스는 접근이 금지된다. (X)
**4) 다른 패키지에 있는 상속받은 자식클래스의 객체를 통해서도 접근이 불가능하다.(부모에 접근X) (X)

3. protected 접근지정자
1) 같은 패키지에 있는 클래스들끼리 접근 가능하다. (O)
2) 자기 클래스내에서도 접근 가능하다. (O)
3) 다른 패키지에 있는 클래스 접근이 금지된다. (X)
4) 다른 패키지에 있는 상속받은 자식클래스의 객체를 통해서도 접근이 가능하다. (O)

4. public 접근지정자
1) 같은 패키지에 있는 클래스들끼리 접근이 가능하다. (O)
2) 자기 클래스내에서도 접근 가능하다. (O)
3) 다른 패키지에 있는 클래스 접근이 가능하다. (O)
4) 다른 패키지에 있는 상속받은 자식클래스의객체를 통해서도 접근이 가능하다. (O)

** public 예외적인 부분 **

- 접근지정자가 멤버변수, 메서드에게만 부여하는것이 아니다.
- 클래스 앞에도 접근지정자를 부여할 수 가 있다.

즉, 멤버변수건 클래스 앞이건 public을 준다는 전제조건하에 전부 가능한 것이다.
*************************************************